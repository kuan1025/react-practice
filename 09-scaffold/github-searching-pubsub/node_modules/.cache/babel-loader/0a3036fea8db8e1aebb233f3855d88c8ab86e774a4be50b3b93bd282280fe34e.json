{"ast":null,"code":"(function (scope) {\n  'use strict';\n\n  var pubsubInstance = null;\n  var pubsubConfig = null;\n  if (typeof pubsub === 'object') {\n    pubsubConfig = pubsub;\n    //node.js config from global\n  } else if (typeof global === 'object' && typeof global.pubsubConfig === 'object') {\n    pubsubConfig = global.pubsubConfig;\n  }\n  function Pubsub(config) {\n    var _eventObject = {};\n    var options = {\n      separator: config && config.separator ? config.separator : '/',\n      recurrent: config && typeof config.recurrent === 'boolean' ? config.recurrent : false,\n      depth: config && typeof config.depth === 'number' ? config.depth : null,\n      async: config && typeof config.async === 'boolean' ? config.async : false,\n      context: config && config.context ? config.context : null,\n      log: config && config.log ? config.log : false\n    };\n    function forEach(dataArray, callback) {\n      var i = 0,\n        arrayLength = dataArray.length;\n      for (i = 0; i < arrayLength; i++) {\n        callback(i, dataArray[i]);\n      }\n    }\n    function isArray(obj) {\n      return Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n    }\n    function executeCallback(subscriptions, args, async) {\n      async = typeof async === 'boolean' ? async : options.async;\n      if (!subscriptions.length) {\n        return;\n      }\n\n      // clone array - callbacks can unsubscribe other subscriptions\n      // reduces a lot performance but is safe\n      var executedSubscriptions = subscriptions.slice();\n      forEach(executedSubscriptions, function (subscriptionId, subscription) {\n        if (typeof subscription === 'object' && executedSubscriptions.hasOwnProperty(subscriptionId)) {\n          if (async) {\n            setTimeout(function () {\n              subscription.callback.apply(subscription.context, args);\n            }, 4);\n          } else {\n            subscription.callback.apply(subscription.context, args);\n          }\n        }\n      });\n    }\n    function executePublishWildcard(nsObject, args) {\n      var nsElement;\n      for (nsElement in nsObject) {\n        if (nsElement[0] !== '_' && nsObject.hasOwnProperty(nsElement)) {\n          executeCallback(nsObject[nsElement]._events, args);\n        }\n      }\n    }\n    function publish(nsObject, args, parts, params) {\n      // work on copy - not on reference\n      parts = parts.slice();\n      var iPart = parts.shift();\n      var depth = params.depth;\n      var async = params.async;\n      var partsLength = params.partsLength;\n      var recurrent = params.recurrent;\n      var partNumber = partsLength - parts.length;\n\n      // parts is empty\n      if (!iPart) {\n        executeCallback(nsObject._events, args, async);\n        return;\n      }\n      // handle subscribe wildcard\n      if (typeof nsObject['*'] !== 'undefined') {\n        publish(nsObject['*'], args, parts, params);\n      }\n\n      // handle publish wildcard\n      if (iPart === '*') {\n        executePublishWildcard(nsObject, args, async);\n      }\n\n      // no namespace = leave publish\n      if (typeof nsObject[iPart] === \"undefined\") {\n        if (params.log) {\n          console.warn('There is no ' + params.nsString + ' subscription');\n        }\n        return;\n      }\n      nsObject = nsObject[iPart];\n      if (recurrent === true && typeof depth !== 'number') {\n        //depth is not defined\n        executeCallback(nsObject._events, args, async);\n        if (parts.length === 0) {\n          return;\n        }\n      } else if (recurrent === true && typeof depth === 'number' && partNumber >= partsLength - depth) {\n        //if depth is defined\n        executeCallback(nsObject._events, args, async);\n      }\n      publish(nsObject, args, parts, params);\n    }\n    function executeSubscribeWildcard(nsObject, args, params) {\n      var parts = params.parts;\n      var async = params.async;\n      var nextPart = null;\n      if (parts.length === 0) {\n        executeCallback(nsObject._events, args, async);\n      } else {\n        nextPart = parts.shift();\n        if (nsObject[nextPart]) {\n          executeSubscribeWildcard(nsObject[nextPart], args, {\n            parts: parts,\n            async: async,\n            nsString: params.nsString\n          });\n        }\n      }\n    }\n    function subscribe(nsString, callback, params) {\n      var parts = nsString.split(options.separator),\n        nsObject,\n        //Namespace object to which we attach event\n        context = params && typeof params.context !== 'undefined' ? params.context : options.context,\n        eventObject = null,\n        i = 0;\n      if (!context) {\n        context = callback;\n      }\n\n      //Iterating through _eventObject to find proper nsObject\n      nsObject = _eventObject;\n      for (i = 0; i < parts.length; i += 1) {\n        if (typeof nsObject[parts[i]] === \"undefined\") {\n          nsObject[parts[i]] = {};\n          nsObject[parts[i]]._events = [];\n        }\n        nsObject = nsObject[parts[i]];\n      }\n      eventObject = {\n        callback: callback,\n        context: context // \"this\" parameter in executed function\n      };\n      nsObject._events.push(eventObject);\n      return {\n        namespace: parts.join(options.separator),\n        event: eventObject\n      };\n    }\n    function unsubscribe(subscribeObject) {\n      if (subscribeObject === null || typeof subscribeObject === 'undefined') {\n        return null;\n      }\n      var nsString = subscribeObject.namespace,\n        eventObject = subscribeObject.event,\n        parts = nsString.split(options.separator),\n        nsObject,\n        i = 0;\n\n      //Iterating through _eventObject to find proper nsObject\n      nsObject = _eventObject;\n      for (i = 0; i < parts.length; i += 1) {\n        if (typeof nsObject[parts[i]] === \"undefined\") {\n          if (options.log) {\n            console.error('There is no ' + nsString + ' subscription');\n          }\n          return null;\n        }\n        nsObject = nsObject[parts[i]];\n      }\n      forEach(nsObject._events, function (eventId) {\n        if (nsObject._events[eventId] === eventObject) {\n          nsObject._events.splice(eventId, 1);\n        }\n      });\n    }\n    return {\n      /**\n       * Publish event\n       * @param nsString string namespace string splited by dots\n       * @param args array of arguments given to callbacks\n       * @param params paramaters possible:\n       *        @param recurrent bool should execution be bubbled throught namespace\n       *        @param depth integer how many namespaces separated by dots will be executed\n       */\n      publish: function (nsString, args, params) {\n        var parts = nsString.split(options.separator),\n          recurrent = typeof params === 'object' && params.recurrent ? params.recurrent : options.recurrent,\n          // bubbles event throught namespace if true\n          depth = typeof params === 'object' && params.depth ? params.depth : options.depth,\n          async = typeof params === 'object' && params.async ? params.async : options.async,\n          partsLength = parts.length;\n        if (!parts.length) {\n          if (options.log) {\n            console.error('Wrong namespace provided ' + nsString);\n          }\n          return;\n        }\n        publish(_eventObject, args, parts, {\n          recurrent: recurrent,\n          depth: depth,\n          async: async,\n          parts: parts,\n          nsString: nsString,\n          partsLength: partsLength\n        });\n      },\n      /**\n       * Subscribe event\n       * @param nsString string namespace string splited by dots\n       * @param callback function function executed after publishing event\n       * @param params given params\n       *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n       */\n      subscribe: function (nsString, callback, params) {\n        var self = this,\n          subscriptions = [];\n\n        // array of callbacks - multiple subscription\n        if (isArray(callback)) {\n          forEach(callback, function (number) {\n            var oneCallback = callback[number];\n            subscriptions = subscriptions.concat(self.subscribe(nsString, oneCallback, params));\n          });\n          // array of namespaces - multiple subscription\n        } else if (isArray(nsString)) {\n          forEach(nsString, function (number) {\n            var namespace = nsString[number];\n            subscriptions = subscriptions.concat(self.subscribe(namespace, callback, params));\n          });\n        } else {\n          return subscribe.apply(self, arguments);\n        }\n        return subscriptions;\n      },\n      /**\n       * subscribeOnce event - subscribe once to some event, then unsubscribe immadiately\n       * @param nsString string namespace string splited by dots\n       * @param callback function function executed after publishing event\n       * @param params given params\n       *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n       */\n      subscribeOnce: function (nsString, callback, params) {\n        var self = this,\n          subscription = null;\n        function subscriptionCallback() {\n          var context = this;\n          callback.apply(context, arguments);\n          self.unsubscribe(subscription);\n        }\n        subscription = self.subscribe(nsString, subscriptionCallback, params);\n        return subscription;\n      },\n      /**\n       * Unsubscribe from given subscription\n       * @param subscribeObject subscription object given on subscribe (returned from subscription)\n       */\n      unsubscribe: function (subscribeObject) {\n        var self = this;\n\n        //if we have array of callbacks - multiple subscription\n        if (isArray(subscribeObject)) {\n          forEach(subscribeObject, function (number) {\n            var oneSubscribtion = subscribeObject[number];\n            unsubscribe.apply(self, [oneSubscribtion]);\n          });\n        } else {\n          unsubscribe.apply(self, arguments);\n        }\n      },\n      /**\n       * newInstance - makes new instance of pubsub object with its own config\n       * @param params instance configuration\n       *        @param separator separator (default is \"/\")\n       *        @param recurrent should publish events be bubbled through namespace\n       *        @param async should publish events be asynchronous - not blocking function execution\n       *        @param log console.warn/error every problem\n       */\n      newInstance: function (params) {\n        return new Pubsub(params);\n      }\n    }; //return block\n  }\n  pubsubInstance = new Pubsub(pubsubConfig);\n\n  //if sbd's using requirejs library to load pubsub.js\n  if (typeof define === 'function') {\n    define(pubsubInstance);\n  }\n\n  //node.js\n  if (typeof module === 'object' && module.exports) {\n    module.exports = pubsubInstance;\n  }\n  if (typeof window === 'object') {\n    window.pubsub = pubsubInstance;\n    if (window !== scope) {\n      scope.pubsub = pubsubInstance;\n    }\n  }\n})(this);","map":{"version":3,"names":["scope","pubsubInstance","pubsubConfig","pubsub","global","Pubsub","config","_eventObject","options","separator","recurrent","depth","async","context","log","forEach","dataArray","callback","i","arrayLength","length","isArray","obj","Array","Object","prototype","toString","call","executeCallback","subscriptions","args","executedSubscriptions","slice","subscriptionId","subscription","hasOwnProperty","setTimeout","apply","executePublishWildcard","nsObject","nsElement","_events","publish","parts","params","iPart","shift","partsLength","partNumber","console","warn","nsString","executeSubscribeWildcard","nextPart","subscribe","split","eventObject","push","namespace","join","event","unsubscribe","subscribeObject","error","eventId","splice","self","number","oneCallback","concat","arguments","subscribeOnce","subscriptionCallback","oneSubscribtion","newInstance","define","module","exports","window"],"sources":["/Users/Damian/side-project/react-practice/09-scaffold/github-searching-pubsub/node_modules/pubsub.js/pubsub.js"],"sourcesContent":["(function(scope) {\n\t'use strict';\n\tvar pubsubInstance = null;\n\tvar pubsubConfig = null;\n\n\tif(typeof pubsub === 'object') {\n\t\tpubsubConfig = pubsub;\n\t//node.js config from global\n\t} else if(typeof global === 'object' && typeof global.pubsubConfig === 'object') {\n\t\tpubsubConfig = global.pubsubConfig;\n\t}\n\n\tfunction Pubsub(config) {\n\t\tvar _eventObject = {};\n\t\tvar options = {\n\t\t\tseparator : (config && config.separator) ? config.separator : '/',\n\t\t\trecurrent : (config && typeof config.recurrent === 'boolean') ? config.recurrent : (false),\n\t\t\tdepth     : (config && typeof config.depth === 'number') ? config.depth : null,\n\t\t\tasync     : (config && typeof config.async === 'boolean') ? config.async : (false),\n\t\t\tcontext   : (config && config.context) ? config.context : null,\n\t\t\tlog       : (config && config.log) ? config.log : (false)\n\t\t};\n\n\t\tfunction forEach(dataArray, callback) {\n\t\t\tvar i = 0,\n\t\t\t\tarrayLength = dataArray.length;\n\n\t\t\tfor(i = 0; i < arrayLength; i++) {\n\t\t\t\tcallback(i, dataArray[i]);\n\t\t\t}\n\t\t}\n\n        function isArray (obj) {\n\t\t\treturn Array.isArray ? Array.isArray(obj) : Object.prototype.toString.call(obj) === '[object Array]';\n        }\n\n        function executeCallback(subscriptions, args, async) {\n\t\t\tasync = (typeof async === 'boolean') ? async : options.async;\n\t\t\tif(!subscriptions.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// clone array - callbacks can unsubscribe other subscriptions\n\t\t\t// reduces a lot performance but is safe\n\t\t\tvar executedSubscriptions = subscriptions.slice();\n\n\t\t\tforEach(executedSubscriptions, function(subscriptionId, subscription) {\n\t\t\t\tif(typeof subscription === 'object' && executedSubscriptions.hasOwnProperty(subscriptionId)) {\n\t\t\t\t\tif(async) {\n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\tsubscription.callback.apply(subscription.context, args);\n\t\t\t\t\t\t}, 4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubscription.callback.apply(subscription.context, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction executePublishWildcard(nsObject, args) {\n\t\t\tvar nsElement;\n\t\t\tfor(nsElement in nsObject) {\n\t\t\t\tif(nsElement[0] !== '_' && nsObject.hasOwnProperty(nsElement)) {\n\t\t\t\t\texecuteCallback(nsObject[nsElement]._events, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction publish(nsObject, args, parts, params) {\n\t\t\t// work on copy - not on reference\n\t\t\tparts = parts.slice();\n\n\t\t\tvar iPart = parts.shift();\n\t\t\tvar depth = params.depth;\n\t\t\tvar async = params.async;\n\t\t\tvar partsLength = params.partsLength;\n\t\t\tvar recurrent = params.recurrent;\n\t\t\tvar partNumber = (partsLength - parts.length);\n\n\t\t\t// parts is empty\n\t\t\tif(!iPart) {\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// handle subscribe wildcard\n\t\t\tif(typeof nsObject['*'] !== 'undefined') {\n\t\t\t\tpublish(nsObject['*'], args, parts, params);\n\t\t\t}\n\n\t\t\t// handle publish wildcard\n\t\t\tif(iPart === '*') {\n\t\t\t\texecutePublishWildcard(nsObject, args, async);\n\t\t\t}\n\n\t\t\t// no namespace = leave publish\n\t\t\tif(typeof nsObject[iPart] === \"undefined\") {\n\t\t\t\tif(params.log) {\n\t\t\t\t\tconsole.warn('There is no ' + params.nsString + ' subscription');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnsObject = nsObject[iPart];\n\n\t\t\tif(recurrent === true && typeof depth !== 'number') { //depth is not defined\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t\tif(parts.length === 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if(recurrent === true && typeof depth === 'number' && partNumber >= (partsLength - depth)) { //if depth is defined\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t}\n\n\t\t\tpublish(nsObject, args, parts, params);\n\t\t}\n\n\t\tfunction executeSubscribeWildcard(nsObject, args, params) {\n\t\t\tvar parts = params.parts;\n\t\t\tvar async = params.async;\n\t\t\tvar nextPart = null;\n\n\t\t\tif(parts.length === 0) {\n\t\t\t\texecuteCallback(nsObject._events, args, async);\n\t\t\t} else {\n\t\t\t\tnextPart = parts.shift();\n\n\t\t\t\tif(nsObject[nextPart]) {\n\t\t\t\t\texecuteSubscribeWildcard(nsObject[nextPart], args, {\n\t\t\t\t\t\tparts : parts,\n\t\t\t\t\t\tasync : async,\n\t\t\t\t\t\tnsString : params.nsString\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction subscribe(nsString, callback, params) {\n\t\t\tvar parts = nsString.split(options.separator),\n\t\t\t\tnsObject, //Namespace object to which we attach event\n\t\t\t\tcontext = (params && typeof params.context !== 'undefined') ? params.context : options.context,\n\t\t\t\teventObject = null,\n\t\t\t\ti = 0;\n\n\t\t\tif(!context) {\n\t\t\t\tcontext = callback;\n\t\t\t}\n\n\t\t\t//Iterating through _eventObject to find proper nsObject\n\t\t\tnsObject = _eventObject;\n\t\t\tfor(i = 0; i < parts.length; i += 1) {\n\t\t\t\tif(typeof nsObject[parts[i]] === \"undefined\") {\n\t\t\t\t\tnsObject[parts[i]] = {};\n\t\t\t\t\tnsObject[parts[i]]._events = [];\n\t\t\t\t}\n\t\t\t\tnsObject = nsObject[parts[i]];\n\t\t\t}\n\n\t\t\teventObject = {\n\t\t\t\tcallback\t: callback,\n\t\t\t\tcontext\t\t: context // \"this\" parameter in executed function\n\t\t\t};\n\n\t\t\tnsObject._events.push(eventObject);\n\t\t\treturn { namespace : parts.join(options.separator),\n\t\t\t\tevent : eventObject };\n\t\t}\n\n\t\tfunction unsubscribe(subscribeObject) {\n\t\t\tif(subscribeObject === null || typeof subscribeObject === 'undefined') {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar nsString = subscribeObject.namespace,\n\t\t\t\teventObject = subscribeObject.event,\n\t\t\t\tparts = nsString.split(options.separator),\n\t\t\t\tnsObject,\n\t\t\t\ti = 0;\n\n\t\t\t//Iterating through _eventObject to find proper nsObject\n\t\t\tnsObject = _eventObject;\n\t\t\tfor(i = 0; i < parts.length; i += 1) {\n\t\t\t\tif(typeof nsObject[parts[i]] === \"undefined\") {\n\t\t\t\t\tif(options.log) {\n\t\t\t\t\t\tconsole.error('There is no ' + nsString + ' subscription');\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tnsObject = nsObject[parts[i]];\n\t\t\t}\n\n\t\t\tforEach(nsObject._events, function(eventId) {\n\t\t\t\tif(nsObject._events[eventId] === eventObject) {\n\t\t\t\t\tnsObject._events.splice(eventId, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\t/**\n\t\t\t * Publish event\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param args array of arguments given to callbacks\n\t\t\t * @param params paramaters possible:\n\t\t\t *        @param recurrent bool should execution be bubbled throught namespace\n\t\t\t *        @param depth integer how many namespaces separated by dots will be executed\n\t\t\t */\n\t\t\tpublish : function(nsString, args, params) {\n\t\t\t\tvar parts = nsString.split(options.separator),\n\t\t\t\t\trecurrent = (typeof params === 'object' && params.recurrent) ? params.recurrent : options.recurrent, // bubbles event throught namespace if true\n\t\t\t\t\tdepth = (typeof params === 'object' && params.depth) ? params.depth : options.depth,\n\t\t\t\t\tasync = (typeof params === 'object' && params.async) ? params.async : options.async,\n\t\t\t\t\tpartsLength = parts.length;\n\n\t\t\t\tif(!parts.length) {\n\t\t\t\t\tif(options.log) {\n\t\t\t\t\t\tconsole.error('Wrong namespace provided ' + nsString);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpublish(_eventObject, args, parts, {\n\t\t\t\t\trecurrent : recurrent,\n\t\t\t\t\tdepth : depth,\n\t\t\t\t\tasync : async,\n\t\t\t\t\tparts : parts,\n\t\t\t\t\tnsString : nsString,\n\t\t\t\t\tpartsLength : partsLength\n\t\t\t\t});\n\t\t\t},\n\t\t\t/**\n\t\t\t * Subscribe event\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param callback function function executed after publishing event\n\t\t\t * @param params given params\n\t\t\t *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n\t\t\t */\n\t\t\tsubscribe : function(nsString, callback, params) {\n\t\t\t\tvar self = this,\n\t\t\t\t\tsubscriptions = [];\n\n\t\t\t\t// array of callbacks - multiple subscription\n\t\t\t\tif(isArray(callback)) {\n\t\t\t\t\tforEach(callback, function(number) {\n\t\t\t\t\t\tvar oneCallback = callback[number];\n\n\t\t\t\t\t\tsubscriptions =\tsubscriptions.concat(self.subscribe(nsString, oneCallback, params));\n\t\t\t\t\t});\n\t\t\t\t// array of namespaces - multiple subscription\n\t\t\t\t} else if(isArray(nsString)) {\n\t\t\t\t\tforEach(nsString, function(number) {\n\t\t\t\t\t\tvar namespace = nsString[number];\n\n\t\t\t\t\t\tsubscriptions =\tsubscriptions.concat(self.subscribe(namespace, callback, params));\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn subscribe.apply(self, arguments);\n\t\t\t\t}\n\t\t\t\treturn subscriptions;\n\t\t\t},\n\t\t\t/**\n\t\t\t * subscribeOnce event - subscribe once to some event, then unsubscribe immadiately\n\t\t\t * @param nsString string namespace string splited by dots\n\t\t\t * @param callback function function executed after publishing event\n\t\t\t * @param params given params\n\t\t\t *\t\t@param context object/nothing Optional object which will be used as \"this\" in callback\n\t\t\t */\n\t\t\tsubscribeOnce : function(nsString, callback, params) {\n\t\t\t\tvar self = this,\n\t\t\t\t\tsubscription = null;\n\n\t\t\t\tfunction subscriptionCallback() {\n\t\t\t\t\tvar context = this;\n\n\t\t\t\t\tcallback.apply(context, arguments);\n\t\t\t\t\tself.unsubscribe(subscription);\n\t\t\t\t}\n\n\t\t\t\tsubscription = self.subscribe(nsString, subscriptionCallback, params);\n\t\t\t\treturn subscription;\n\t\t\t},\n\t\t\t/**\n\t\t\t * Unsubscribe from given subscription\n\t\t\t * @param subscribeObject subscription object given on subscribe (returned from subscription)\n\t\t\t */\n\t\t\tunsubscribe : function(subscribeObject) {\n\t\t\t\tvar self = this;\n\n\t\t\t\t//if we have array of callbacks - multiple subscription\n\t\t\t\tif(isArray(subscribeObject)) {\n\t\t\t\t\tforEach(subscribeObject, function(number) {\n\t\t\t\t\t\tvar oneSubscribtion = subscribeObject[number];\n\n\t\t\t\t\t\tunsubscribe.apply(self, [oneSubscribtion]);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tunsubscribe.apply(self, arguments);\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * newInstance - makes new instance of pubsub object with its own config\n\t\t\t * @param params instance configuration\n\t\t\t *        @param separator separator (default is \"/\")\n\t\t\t *        @param recurrent should publish events be bubbled through namespace\n\t\t\t *        @param async should publish events be asynchronous - not blocking function execution\n\t\t\t *        @param log console.warn/error every problem\n\t\t\t */\n\t\t\tnewInstance : function(params) {\n\t\t\t\treturn new Pubsub(params);\n\t\t\t}\n\t\t}; //return block\n\t}\n\tpubsubInstance = new Pubsub(pubsubConfig);\n\n\t//if sbd's using requirejs library to load pubsub.js\n\tif(typeof define === 'function') {\n\t\tdefine(pubsubInstance);\n\t}\n\n\t//node.js\n\tif(typeof module === 'object' && module.exports) {\n\t\tmodule.exports = pubsubInstance;\n\t}\n\n\tif(typeof window === 'object') {\n\t\twindow.pubsub = pubsubInstance;\n\t\tif(window !== scope) {\n\t\t\tscope.pubsub = pubsubInstance;\n\t\t}\n\t}\n})(this);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}